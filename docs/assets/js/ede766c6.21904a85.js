"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6359],{28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>s});var o=a(96540);const n={},r=o.createContext(n);function i(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},32386:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/2023/12/22/hands-on-with-kiota","editUrl":"https://github.com/MarkZither/mywyamblog/tree/main/docs/blog/2023-12-22-hands-on-with-kiota.md","source":"@site/blog/2023-12-22-hands-on-with-kiota.md","title":"Untitled","description":"For years I have felt that if you are offering a public API it should be documented well enough for consumers to generate a client library in whatever language they are using, it is almost implausible to create client libraries in all languages your consumers might use, but a good OpenAPI definition allows consumers to understand an API and use tools to generate client libraries.  Over the years I have worked with NSwag, which was good but put all the code in 1 file which I didn\'t like. AutoRest, which seemed to get more difficult to work with when V3 was released, so I looked around again and found OpenAPI Generator, which is great but needs Java. With the release of Kiota I was excited to look at how a dotnet tool could tackle the same requirement.  ## What is Kiota?  Kiota is a client generator for OpenAPI and was introduced at .NET Conf 2023.","date":"2023-12-22T00:00:00.000Z","tags":[],"readingTime":0.98,"hasTruncateMarker":false,"authors":[{"name":"Mark Burton","title":"Software Engineer & Technical Writer","url":"https://github.com/MarkZither","imageURL":"https://github.com/MarkZither.png","key":"mark-burton","page":null}],"frontMatter":{"title":"Untitled","authors":["mark-burton"],"date":"2023-12-22"},"unlisted":false,"prevItem":{"title":"Untitled","permalink":"/docs/blog/2024/01/10/creating-a-chatbot-with-llm-rag"},"nextItem":{"title":"Untitled","permalink":"/docs/blog/2023/11/11/making-zakwas-and-zurek"}}')},55925:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var o=a(32386),n=a(74848),r=a(28453);const i={title:"Untitled",authors:["mark-burton"],date:"2023-12-22"},s=void 0,l={authorsImageUrls:[void 0]},c=[];function u(e){const t={a:"a",p:"p",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"For years I have felt that if you are offering a public API it should be documented well enough for consumers to generate a client library in whatever language they are using, it is almost implausible to create client libraries in all languages your consumers might use, but a good OpenAPI definition allows consumers to understand an API and use tools to generate client libraries.  Over the years I have worked with NSwag, which was good but put all the code in 1 file which I didn't like. AutoRest, which seemed to get more difficult to work with when V3 was released, so I looked around again and found OpenAPI Generator, which is great but needs Java. With the release of Kiota I was excited to look at how a dotnet tool could tackle the same requirement.  ## What is Kiota?  Kiota is a client generator for OpenAPI and was introduced at .NET Conf 2023."}),"\n",(0,n.jsxs)(t.p,{children:['<iframe width="560" height="315" src="https:/',(0,n.jsx)(t.a,{href:"http://www.youtube.comembedsQ9Pv-rQ1s8?si=4wl3jIZWa3VY9sWF",children:"www.youtube.comembedsQ9Pv-rQ1s8?si=4wl3jIZWa3VY9sWF"}),'"',' title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>',(0,n.jsx)("iframe",{}),"  ## Quickstart Kiota Project  ",(0,n.jsx)(t.a,{href:"https:/learn.microsoft.comen-usopenapikiotaquickstartsdotnet",children:"Learn"})]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);