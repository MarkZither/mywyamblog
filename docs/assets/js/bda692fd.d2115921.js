"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3403],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(96540);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}},46336:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var r=n(85418),o=n(74848),s=n(28453);const i={title:"","Experimenting with YARP":'A Reverse Proxy""',authors:["mark-burton"],tags:["ASP.NET Core","YARP","Reverse Proxy","NGINX"],description:"YARP is a reverse proxy toolkit for building fast proxy servers in .NET using the infrastructure from ASP.NET and .NET.",date:"2020-09-14"},a=void 0,l={authorsImageUrls:[void 0]},c=[];function u(e){const t={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"A Route is the inbound URL which the reverse proxy is going to act on. The cluster is a list of potential destination URLs."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'"ReverseProxy": {\n  "Routes": [\n    {\n      "RouteId": "LoginServiceRoute",\n      "ClusterId": "clusterLoginService",\n      "Match": {\n        "Path": "/loginservice/{**remainder}"\n      },\n      "Transforms": [\n        {\n          "PathRemovePrefix": "/loginservice"\n        }\n      ]\n    }\n  ],\n  "Clusters": {\n    "clusterLoginService": {\n      "Destinations": {\n        "clusterLoginService/destination1": {\n          "Address": "https://localhost:1116/"\n        }\n      }\n    }\n  }\n}\n```  This would be similar to this NGINX virtual server configuration.\n\n```nginx\nserver {\n  listen 80;\n  server_name localhost;\n  location /loginservice/ {\n    proxy_pass https://localhost:1116/;\n  }\n}\n```  Take care when adding a transformation to a route, **do not** add a single transformation, it must be wrapped in [] or you will get no transformations and lots of confusion.\n\nMy mistake looked like this\n\n```json\n{\n  "RouteId": "TestServiceRoute",\n  "ClusterId": "clusterTestService",\n  "Match": {\n    "Path": "/testservice/{**remainder}"\n  },\n  "Transforms": {\n    "PathRemovePrefix": "/testservice"\n  }\n},\n```  It took debugging into the YARP source to figure out my mistake which resulted in 503 and 404 errors due to URLs like `https://localhost:1116/loginservice/hc` instead of the correct `https://localhost:1116/hc`.\n\n```json\n{\n  "RouteId": "TestServiceRoute",\n  "ClusterId": "clusterTestService",\n  "Match": {\n    "Path": "/testservice/{**remainder}"\n  },\n  "Transforms": [ // <-- was missing\n    {\n      "PathRemovePrefix": "/testservice"\n    }\n  ] // <-- was missing\n},\n```  It is easier to see the issue as soon as you start adding additional transformations. In preview 5 for example it is possible to transform route values to querystring parameters, now it is clear that `Transformations` must be an array.\n\n```json\n{\n  "RouteId": "TestPatternServiceRoute",\n  "ClusterId": "clusterTestService",\n  "Match": {\n    "Path": "/testpatternservice/{**remainder}"\n  },\n  "Transforms": [\n    {\n      "PathPattern": "/search"\n    },\n    {\n      "QueryRouteParameter": "q",\n      "Append": "remainder"\n    }\n  ]\n},\n'})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},85418:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/2020/09/14/experimenting-with-yarp-a-reverse-proxy","editUrl":"https://github.com/MarkZither/mywyamblog/tree/main/docs/blog/2020-09-14-experimenting-with-yarp-a-reverse-proxy.md","source":"@site/blog/2020-09-14-experimenting-with-yarp-a-reverse-proxy.md","title":"","description":"YARP is a reverse proxy toolkit for building fast proxy servers in .NET using the infrastructure from ASP.NET and .NET.","date":"2020-09-14T00:00:00.000Z","tags":[{"inline":false,"label":"ASP.NET Core","permalink":"/docs/blog/tags/aspnet-core","description":"Microsoft ASP.NET Core framework"},{"inline":false,"label":"YARP","permalink":"/docs/blog/tags/yarp","description":"Yet Another Reverse Proxy"},{"inline":false,"label":"Reverse Proxy","permalink":"/docs/blog/tags/reverse-proxy","description":"Reverse proxy technologies"},{"inline":false,"label":"NGINX","permalink":"/docs/blog/tags/nginx","description":"NGINX web server"}],"readingTime":1.12,"hasTruncateMarker":false,"authors":[{"name":"Mark Burton","title":"Software Engineer & Technical Writer","url":"https://github.com/MarkZither","imageURL":"https://github.com/MarkZither.png","key":"mark-burton","page":null}],"frontMatter":{"title":"","Experimenting with YARP":"A Reverse Proxy\\"\\"","authors":["mark-burton"],"tags":["ASP.NET Core","YARP","Reverse Proxy","NGINX"],"description":"YARP is a reverse proxy toolkit for building fast proxy servers in .NET using the infrastructure from ASP.NET and .NET.","date":"2020-09-14"},"unlisted":false,"prevItem":{"title":"Local Hostname Resolution To Port","permalink":"/docs/blog/2020/09/17/local-hostname-resolution-to-port"},"nextItem":{"title":"Getting the most out of Swagger in your ASP.NET Core api","permalink":"/docs/blog/2020/09/09/getting-the-most-out-of-swagger-in-your-asp-net-core-api"}}')}}]);