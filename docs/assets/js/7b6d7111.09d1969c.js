"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6236],{4976:e=>{e.exports=JSON.parse('{"permalink":"/docs/blog/2020/09/08/secure-asp-net-core-health-checks-to-a-specific-port","editUrl":"https://github.com/MarkZither/mywyamblog/tree/main/docs/blog/2020-09-08-secure-asp-net-core-health-checks-to-a-specific-port.md","source":"@site/blog/2020-09-08-secure-asp-net-core-health-checks-to-a-specific-port.md","title":"Secure ASP.NET Core Health Checks to a specific port","description":"Health Checks in ASP.NET Core can give valuable insights into the health of services, but that includes sensitive data that should not be leaked externally.","date":"2020-09-08T00:00:00.000Z","tags":[{"inline":false,"label":"ASP.NET Core","permalink":"/docs/blog/tags/aspnet-core","description":"Microsoft ASP.NET Core framework"},{"inline":false,"label":"Health Checks","permalink":"/docs/blog/tags/health-checks","description":"Application health monitoring"}],"readingTime":1.95,"hasTruncateMarker":false,"authors":[{"name":"Mark Burton","title":"Software Engineer & Technical Writer","url":"https://github.com/MarkZither","imageURL":"https://github.com/MarkZither.png","key":"mark-burton","page":null}],"frontMatter":{"title":"Secure ASP.NET Core Health Checks to a specific port","authors":["mark-burton"],"tags":["ASP.NET Core","Health Checks"],"description":"Health Checks in ASP.NET Core can give valuable insights into the health of services, but that includes sensitive data that should not be leaked externally.","date":"2020-09-08"},"unlisted":false,"prevItem":{"title":"How to Setup ASP.NET Core Health Check UI","permalink":"/docs/blog/2020/09/09/how-to-setup-asp-net-core-health-check-ui"},"nextItem":{"title":"Secure Swagger on ASP.NET Core by address and port","permalink":"/docs/blog/2020/09/08/secure-swagger-on-asp-net-core-by-address-and-port"}}')},22296:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>n,toc:()=>h});var n=o(4976),a=o(74848),s=o(28453);const i={title:"Secure ASP.NET Core Health Checks to a specific port",authors:["mark-burton"],tags:["ASP.NET Core","Health Checks"],description:"Health Checks in ASP.NET Core can give valuable insights into the health of services, but that includes sensitive data that should not be leaked externally.",date:"2020-09-08"},r=void 0,c={authorsImageUrls:[void 0]},h=[];function l(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["To secure Health Checks it is possible to make them available on internal addresses only and on a different port to the publicly served pagesAPI endpoints.  First we need to make the service available over 2 different ports, this can be achieved by adding a Urls value to the appsettings.config.  ",(0,a.jsx)(t.code,{children:'json  "Logging": \\\\\\{  "IncludeScopes": false,  "LogLevel": \\{  "Default": "Debug",  "System": "Information",  "Microsoft": "Information"  \\\\}  },  "Urls": "http:/localhost:1114;http:/localhost:1115",  "ManagementPort": "1115",  "ConnectionStrings": \\\\{  "LoginServiceDb": "Data Source=.,11433;Initial Catalog=LoginServiceDatabase;Integrated Security=true;"  \\}, '}),"  This can be done in several ways, and is described in more detail by Andrew Lock in his post ",(0,a.jsx)(t.a,{href:"https:/andrewlock.net5-ways-to-set-the-urls-for-an-aspnetcore-app",children:"5 ways to set the URLs for an ASP.NET Core app"}),".  Now when you debug the service you should see in the log that it is listening on 2 ports  ```\ninfo: Microsoft.Hosting.Lifetime[0]  Now listening on: http:/localhost:1114\ninfo: Microsoft.Hosting.Lifetime[0]  Now listening on: http:/localhost:1115\ninfo: Microsoft.Hosting.Lifetime[0]  Application started. Press Ctrl+C to shut down."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-:::primary",children:'**Special note if you are using http.sys** If you want to run this over https you will need to take care of the port reservation and certification binding. I have a explanation of that in the GitHub Repo README.\n:::  Now that we have the service listening on 2 addresses we can specify one of them will serve up the Health Checks by setting the `ManagementPort`.  In `startup.cs` we can use the `ManagementPort` to secure the Health Check endpoint  ```csharp  HealthCheck middleware  app.UseHealthChecks("hc", $"\\\\{Configuration["ManagementPort"]\\}", new HealthCheckOptions() \\\\{  Predicate = _ => true,  ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse  \\});  app.UseEndpoints(endpoints => \\\\\\{  endpoints.MapControllerRoute("default", "\\{controller=Home\\\\}\\{action=Index\\}\\\\{id?\\}");  endpoints.MapHealthChecks("health").RequireHost($"*:\\\\{Configuration["ManagementPort"]\\}");  });\n```  If you debug now you will have access to the `health` endpoint only on the `ManagementPort` and not on the public facing URL.  ![HealthCheck external shows 404 while internal shows overall health status](/img/health_endpoint.png) More interestingly you can also go to the `hc` endpoint, this contains more detailed information about the state of the service and therefore needs to be secured.  ![HealthCheck external shows 404 while internal shows detailed health status](/img/hc_endpoint.png) Now you can safely get the status of your services reported as json, but there are 2 further aspects of ASP.NET Core Health Checks, the UI and push-based monitoring, i will cover those in parts 2 and 3.\n'})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>r});var n=o(96540);const a={},s=n.createContext(a);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);